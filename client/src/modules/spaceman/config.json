{
  "stages": [
    {
      "testCases": "const SpacemanContract = artifacts.require('SpacemanContract');\ncontract('SpacemanContract', function(accounts) {\n  let contract;\n  let _astronaut = accounts[0];\n  let _arbiter = accounts[1];\n  let _shipper = accounts[2];\n  before(async () => {\n      contract = await SpacemanContract.new(_arbiter, _shipper, {\n         from: _astronaut,\n         gasPrice: 0,\n      });\n  });\n  it('should set an arbiter', async function() {\n      let arbiter = await contract.arbiter.call();\n      assert.deepEqual(arbiter, _arbiter);\n  });\n  it('should set an astronaut', async function() {\n      let astronaut = await contract.astronaut.call();\n      assert.deepEqual(astronaut, _astronaut);\n  });\n  it('should set an shipper', async function() {\n      let shipper = await contract.shipper.call();\n      assert.deepEqual(shipper, _shipper);\n  });\n});",
      "referenceSolution": "pragma solidity ^0.4.13;\n\ncontract SpacemanContract {\n  address public astronaut;\n  address public shipper;\n  address public arbiter;\n\n  function SpacemanContract(address _arbiter, address _shipper) public   {\n    arbiter = _arbiter;\n    shipper = _shipper;\n    astronaut = msg.sender;\n  }\n}\n",
    },
    {
      "testCases": "const SpacemanContract = artifacts.require('SpacemanContract');\ncontract('SpacemanContract', function(accounts) {\n  let contract;\n  let _astronaut = accounts[0];\n  let _arbiter = accounts[1];\n  let _shipper = accounts[2];\n  before(async () => {\n      contract = await SpacemanContract.new(_arbiter, _shipper, {\n         from: _astronaut,\n         gasPrice: 0,\n      });\n  });\n  describe('Fund Stage tests', function() {\n    it('should be able to send ether', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      await contract.pay({ value: ether, from: _astronaut });\n      let balance = await web3.eth.getBalance(contract.address);\n      assert.equal(balance.toString(), ether);\n    })\n    it('should error if its the shipper', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      const promise = contract.pay({ value: ether, from: _shipper });\n      await expectThrow(promise);\n    })\n    it('should log that it was paid', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      let tx = await contract.pay({ value: ether, from: _astronaut });\n      console.log(findEvent(tx, 'Paid'))\n      assert(findEvent(tx, 'Paid'));\n    })\n  })\n  describe('Constructor Stage tests', function() {\n    it('should set an arbiter', async function() {\n        let arbiter = await contract.arbiter.call();\n        assert.deepEqual(arbiter, _arbiter);\n    });\n    it('should set an astronaut', async function() {\n        let astronaut = await contract.astronaut.call();\n        assert.deepEqual(astronaut, _astronaut);\n    });\n    it('should set an shipper', async function() {\n        let shipper = await contract.shipper.call();\n        assert.deepEqual(shipper, _shipper);\n    });\n  })\n});\n\nasync function expectThrow(promise) {\n  const errMsg = 'Expected throw not received';\n  try {\n    await promise;\n  } catch (err) {\n    assert(err.toString().includes('invalid opcode'), errMsg);\n    return;\n  }\n  assert.fail(errMsg);\n}\n\nfunction findEvent(transaction, evt) {\n  let event = transaction.logs.filter(({ event }) => event === evt)[0];\n  if(!event) throw `Remember to call ${evt} event!`;\n  return event.args;\n}",
      "referenceSolution": "pragma solidity ^0.4.13;\n\ncontract SpacemanContract {\n  address public astronaut;\n  address public shipper;\n  address public arbiter;\n\n  event Paid(uint256 value);\n\n  function SpacemanContract(address _arbiter, address _shipper) public {\n    arbiter = _arbiter;\n    shipper = _shipper;\n    astronaut = msg.sender;\n  }\n\n  function pay() public payable {\n    require(msg.sender == astronaut);\n    Paid(msg.value);\n  }\n}\n",
    },
    {
      "testCases": "const SpacemanContract = artifacts.require('SpacemanContract');\ncontract('SpacemanContract', function(accounts) {\n  let contract;\n  let _astronaut = accounts[0];\n  let _arbiter = accounts[1];\n  let _shipper = accounts[2];\n  beforeEach(async () => {\n      contract = await SpacemanContract.new(_arbiter, _shipper, {\n         from: _astronaut,\n         gasPrice: 0,\n      });\n  });\n  describe('Receive Stage tests', function() {\n    describe ('after paying', function() {\n      beforeEach(async () => {\n        let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n        await contract.pay({ value: ether, from: _astronaut });\n      })\n      it('should error if its the shipper', async () => {\n        const promise = contract.receive({ from: _shipper });\n        await expectThrow(promise);\n      })\n      it('should error if its the astronaut', async () => {\n        let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n        const promise = contract.receive({ from: _astronaut });\n        await expectThrow(promise);\n      })\n      it('should log that it was received', async () => {\n        let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n        let tx = await contract.receive({ from: _arbiter });\n        assert(findEvent(tx, 'Received'));\n      })\n    })\n  })\n  describe('Fund Stage tests', function() {\n    it('should be able to send ether', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      await contract.pay({ value: ether, from: _astronaut });\n      let balance = await web3.eth.getBalance(contract.address);\n      assert.equal(balance.toString(), ether);\n    })\n    it('should error if its the shipper', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      const promise = contract.pay({ value: ether, from: _shipper });\n      await expectThrow(promise);\n    })\n    it('should log that it was paid', async () => {\n      let ether = web3.toBigNumber(web3.toWei('.1', 'Ether'));\n      let tx = await contract.pay({ value: ether, from: _astronaut });\n      assert(findEvent(tx, 'Paid'));\n    })\n  })\n  describe('Constructor Stage tests', function() {\n    it('should set an arbiter', async function() {\n        let arbiter = await contract.arbiter.call();\n        assert.deepEqual(arbiter, _arbiter);\n    });\n    it('should set an astronaut', async function() {\n        let astronaut = await contract.astronaut.call();\n        assert.deepEqual(astronaut, _astronaut);\n    });\n    it('should set an shipper', async function() {\n        let shipper = await contract.shipper.call();\n        assert.deepEqual(shipper, _shipper);\n    });\n  })\n});\n\nasync function expectThrow(promise) {\n  const errMsg = 'Expected throw not received';\n  try {\n    await promise;\n  } catch (err) {\n    assert(err.toString().includes('invalid opcode'), errMsg);\n    return;\n  }\n  assert.fail(errMsg);\n}\n\nfunction findEvent(transaction, evt) {\n  let event = transaction.logs.filter(({ event }) => event === evt)[0];\n  if(!event) throw `Remember to call ${evt} event!`;\n  return event.args;\n}",
      "referenceSolution": "pragma solidity ^0.4.13;\n\ncontract SpacemanContract {\n  address public astronaut;\n  address public shipper;\n  address public arbiter;\n\n  enum State {\n    DEPLOYED,\n    PAID,\n    RECEIVED\n  }\n  State public state;\n\n  event Paid(uint256 value);\n  event Received(uint256 time);\n\n  function SpacemanContract(address _arbiter, address _shipper) public {\n    arbiter = _arbiter;\n    shipper = _shipper;\n    astronaut = msg.sender;\n  }\n\n  function pay() public payable {\n    require(msg.sender == astronaut);\n    state = State.PAID;\n    Paid(msg.value);\n  }\n\n  function receive() public {\n    require(msg.sender == arbiter);\n    require(state == State.PAID);\n    state = State.RECEIVED;\n    Received(now);\n  }\n}\n"
    }
  ]
}
